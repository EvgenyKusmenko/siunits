/* (c) https://github.com/MontiCore/monticore */
package de.monticore;

/* Beta-version: This is intended to become a MontiCore stable grammar. */

/**
 * This grammar defines SI units and other derived units such as 
 * 'm', 'km', 'km^2' or 'm*deg/(h^2*mg)'.
 *
 * The definitions are fully compliant to the definitions given in
 * International Bureau of Weights and Measures (20 May 2019),
 * SI Brochure: The International System of Units (SI) (9th ed.)
 * with exceptions for the aliasing of the non ASCII characters
 * 'µ' to u and 'Ω' to Ohm.
 *
 * SI Units are declared as independent Nonterminal and can then
 * be used as part of a 
 * * value definition, such as "5kg", or
 * * type definition, such as "km/h"
 * 
 * The grammar extends the MontiCore common literals, because it uses
 * natural numbers e.g. as exponent.
 */

grammar SIUnits extends de.monticore.literals.MCCommonLiterals {

    /**
      * Every SIUnit is either a dimensionless unit 
      * such as 'deg' or a SIUnitExpression
      */
    SIUnit =
       SIUnitDimensionless | SIUnitExpression;
// TODO EK: Umbenennung
// wir brauchen noch eine Umbenennung,
// leider ist es mir gerade jetzt erst aufgefallen:
//    SIUnitExpression  ist ja keine(!) Expression.
//    SIUnitExpression  -->  SIType
//    SIUnitExpression  -->  SIUnitType
//    SIUnitExpression  -->  SIUnitKind
//    SIUnitExpression  -->  SIType
//    SIUnitExpression  -->  SIUnitCompound
//    SIUnitExpression  -->  SIUnitComplex
/* Was nehmen wir?
   Man könnte "SIUnitExpression stehen lassen (ähnlich wie TypeExpression
   die sind auch keine Expressions), allerdings müsste es dann
    MultSIUnitExpression  statt SIUnitMultExpression
   heissen.
*/ 

    /**
     * The SIUnitExpression describes an expression containing 
     * SIUnitBasics as primitives so that every combination 
     * of 'x*y', 'x/y', 'x^n' and '(x)' 
     * is possible
     */
    interface SIUnitExpression;

// TODO: der Einfachheit halber hier jeweils das "Expression" streichen
    SIUnitMultExpression implements SIUnitExpression <10> =
        left:SIUnitExpression "*" right:SIUnitExpression;

// TODO: der Einfachheit halber hier jeweils das "Expression" streichen
    SIUnitOneDivExpression implements SIUnitExpression <20> =
        "1/" right:SIUnitExpression;

// TODO: der Einfachheit halber hier jeweils das "Expression" streichen
    SIUnitDivExpression implements SIUnitExpression <30> =
        left:SIUnitExpression "/" right:SIUnitExpression;

// TODO: der Einfachheit halber hier jeweils das "Expression" streichen
    SIUnitBracketExpression implements SIUnitExpression <40> =
        "(" SIUnit ")";

// TODO: der Einfachheit halber hier jeweils das "Expression" streichen
    SIUnitExponentExpression implements SIUnitExpression <50> =
        SIUnitExpression "^" exponent:SignedNatLiteral;

    /**
     * The SIUnitBasics are the primitives of the SIUnitExpressions 
     * 
     * SIUnitBasics contains the basic SI units without prefixes 
     * such as 'm', 's' or 'kg' 
     * as well as the basic SI units with prefixes 
     * such as 'km', 'mm' or 'ms'.
     *
     * Other derived or officialy accepted units are also contained 
     * ('h', 'day', 'Ohm', ...)
     */
    interface SIUnitBasic extends SIUnitExpression;

    /**
     * UnitBaseDimWithPrefix
     *
     * The regular expression is defined according to:
     * * https://en.wikipedia.org/wiki/Metric_prefix
     * * https://en.wikipedia.org/wiki/SI_base_unit
     * * https://en.wikipedia.org/wiki/SI_derived_unit
     * The regular expression is needed, because SI units shall not be
     * defined as keywords, because they would not be usable e.g. as
     * variable names in other places anymore.
     * See also functions available to handle the stored unit.
     */
//    UnitBaseDimWithPrefix implements SIUnitBasic <10> =
//        { cmpTokenRegEx(1,
//            "(Y|Z|E|P|T|G|M|k|h|da|d|c|m|u|µ|n|p|f|a|z|y)?" +
//            "(m|g|s|A|K|mol|cd|Hz|N|Pa|J|W|C|V|F|Ohm|Ω|S|Wb|T|H|lm|lx|Bq|Gy|Sv|kat|l|L)")
//        }?
//        (unit:Name | UnitWithPrefix);
//
//    token UnitWithPrefix =
//        ("Y"|"Z"|"E"|"P"|"T"|"G"|"M"|"k"|"h"|"da"|"d"|"c"|"m"|"u"|"µ"|"n"|"p"|"f"|"a"|"z"|"y")?
//        ("m"|"g"|"s"|"A"|"K"|"mol"|"cd"|"Hz"|"N"|"Pa"|"J"|"W"|"C"|"V"|"F"|"Ohm"|"Ω"|"S"|"Wb"|"T"|"H"|"lm"|"lx"|"Bq"|"Gy"|"Sv"|"kat"|"l"|"L");

/* TODO:
    Um das schöner zu machen: einen könnten wir die länglichen
    Strings irgendwie auslagern bzw. nur einmal aufschreiben.
    --> das geht durch nutzung eines vollqualifizierten Statischen strings
    oder besser wäre durch eine lokale Variable im Parser. 
    Marita weiss evtl. ob und wie das geht.
   
   Ein alternativer versuch von mir:
    UnitBaseDimWithPrefix implements SIUnitBasic <10> =
    { cmpTokenRegEx(1,
        "(Y|Z|E|P|T|G|M|k|h|da|d|c|m|u|µ|n|p|f|a|z|y)?" +
        "(m|g|s|A|K|mol|cd|Hz|N|Pa|J|W|C|V|F|Ohm|Ω|S|Wb|T|H|lm|lx|Bq|Gy|Sv|kat|l|L)")
    }? (Name | NonNameUnit)
    
    token NonNameUnit = 
         'µ'       UnitChar+ 
       | UnitChar* 'Ω' 
       | 'µ'       'Ω' ;

    fragment token UnitChar = 'a'..'z' | 'A'..'Z' ;


-------
  Wobei ich neugierig bin: Man könnte doch durch geeignete Definition der Regex auch 
  Kombinationen beschreiben, wie etwa "VAh" oder "km/h".
  Das zugehörige Token (und eine natürlich etwas komplexere regexp) wäre etwa:

    token NonNameUnit = 
         '1/' UnitPrefix? UnitKindGroup
       | UnitKindGroup '/' UnitKindGroup
       | UnitKindGroup 'Ω' UnitExponent? UnitKindGroup
        
    fragment token UnitKindGroup = UnitPrefix? ( UnitKind  UnitExponent? )+

    fragment token UnitExponent = '^' '-'? [2-9]
        
    fragment token UnitPrefix = 
        'Y'|'Z'|'E'|'P'|'T'|'G'|'M'|'k'|'h'|'da'|'d'|'c'|'m'|'u'|'µ'|'n'|'p'|'f'|'a'|'z'|'y'

    fragment token UnitKind = 
        'm'|'g'|'s'|'A'|'K'|'mol'|'cd'|'Hz'|'N'|'Pa'|'J'|'W'|'C'|'V'|'F'|'Ohm'|'Ω'|'S'|'Wb'|'T'|'H'|'lm'|'lx'|'Bq'|'Gy'|'Sv'|'kat'|'l'|'L'

Eine solche Definition hätte natürlich ein Risiko:
    km/h könnte nun plötzlich an anderer Stelle fälschlicherweise nicht 
    mehr als Division zweier Variable verarbeitet werden (weshalb ich ja
    Eine sehr fein begrenzte Definition des Tokens vorgenommen habe,
    um das Problem zu begrenzen
    
-------------
Man könnte natürlich "VAh/km" immer noch als drei Token parsen,
und da dann noSpace nutzen.

    (( Anmerkung: ich war davon ausgegangen, dss "/" nur einmal auftritt. Das scheint nicht der Fall zu sein)
        und die Klammern hatte ich auch ignoriert ,
        gut dass es Erklärungen gibt: ```kg/m*s``` &rarr; ```((kg/m)*s)```))

------------------
Und übrigens:
 statt eine vorgegebene Funktion cmpTokenRegEx(1, .... mit 
 länglichem mehrfach wiederholtem String
 könnte man auch eine eigendefinierte Funktion nutzen
 (und da dann solche langen Strings verbergen.
 -- sowas wie: {de.monticore.siunit.isSIUnit(foo())}?
 
 Und Marita sagt Ihnen, was da als foo() einzusetzen ist, um den 
 String des nächsten Token zu bekommen.

        
 */   
    
    SIUnitWithPrefix implements SIUnitBasic <10> =
        { cmpTokenRegEx(1,
            "(Y|Z|E|P|T|G|M|k|h|da|d|c|m|u|µ|n|p|f|a|z|y)?" +
            "(m|g|s|A|K|mol|cd|Hz|N|Pa|J|W|C|V|F|Ohm|Ω|S|Wb|T|H|lm|lx|Bq|Gy|Sv|kat|l|L)") ||
          noSpace(2) && cmpTokenRegEx(2,
            "(m|g|s|A|K|mol|cd|Hz|N|Pa|J|W|C|V|F|Ohm|Ω|S|Wb|T|H|lm|lx|Bq|Gy|Sv|kat|l|L)") ||
          noSpace(2) && cmpToken(2, "Ω") && cmpTokenRegEx(1,
            "(Y|Z|E|P|T|G|M|k|h|da|d|c|m|u|µ|n|p|f|a|z|y)")
        }?
        NameWithMicroOmega;

    NameWithMicroOmega =
        unitWithPrefix:Name | "µ" microUnit:Name | prefixForOhm:Name "Ω" | onlyOhm:"Ω" | microOhm:"µΩ";


    /**
     * OfficallyAcceptedUnit
     *
     * is realized like UnitBaseDimWithPrefix, using a regular matching 
     * expression according to:
     * https://en.wikipedia.org/wiki/Non-SI_units_mentioned_in_the_SI
     */
    OfficallyAcceptedUnit implements SIUnitBasic =
        { next(
          "min","h","d","ha","t","au","Np","B","dB","eV","Da","u")
        }? unit:Name;

    /**
     * CelsiusFahrenheit matches "°C" and "°F"
     *
     * Lookahead needed at the beginning to distinguish with other alternatives
     */
    CelsiusFahrenheit implements SIUnitBasic =
        { cmpToken(2,"F","C") && noSpace(2) }? "°" unit:Name;


    /**
     * SIUnitDimensionless matches "°" and "deg|rad|sr"
     * according to see https://en.wikipedia.org/wiki/SI_derived_unit
     */
    SIUnitDimensionless implements SIUnitBasic =
        "°" |
        { next("deg","rad","sr") }? unit:Name;
        
}
