/* (c) https://github.com/MontiCore/monticore */
package de.monticore;

/* Beta-version: This is intended to become a MontiCore stable grammar. */

/**
 * This grammar defines SI units and other derived units such as 
 * 'm', 'km', 'km^2' or 'm*deg/(h^2*mg)'.
 *
 * The definitions are fully compliant to the definitions given in
 * International Bureau of Weights and Measures (20 May 2019),
 * SI Brochure: The International System of Units (SI) (9th ed.)
 * with exceptions for the aliasing of the non ASCII characters
 * 'µ' to u and 'Ω' to Ohm.
 *
 * SI Units are declared as independent Nonterminal and can then
 * be used as part of a 
 * * value definition, such as "5kg", or
 * * type definition, such as "km/h"
 * 
 * The grammar extends the MontiCore common literals, because it uses
 * natural numbers e.g. as exponent.
 */

grammar SIUnits extends de.monticore.literals.MCCommonLiterals {

    concept antlr {
        parserjava {
            public static final String prefix =
                "(Y|Z|E|P|T|G|M|k|h|da|d|c|m|u|µ|n|p|f|a|z|y)";
            public static final String unitWithPrefix =
                "(m|g|s|A|K|mol|cd|Hz|N|Pa|J|W|C|V|F|Ohm|Ω|S|Wb|T|H|lm|lx|Bq|Gy|Sv|kat|l|L)";
            public static final String unitWithoutPrefix =
                "(min|h|d|ha|t|au|Np|B|dB|eV|Da|u)";
            public static final String units =
                "(m|g|s|A|K|mol|cd|Hz|N|Pa|J|W|C|V|F|Ohm|Ω|S|Wb|T|H|lm|lx|Bq|Gy|Sv|kat|l|L|min|h|d|ha|t|au|Np|B|dB|eV|Da|u)";
            public boolean isUnitWithPrefix() {
                return cmpTokenRegEx(1, prefix + "?" + unitWithPrefix);
            }

            public boolean isUnitWithoutPrefix() {
                return cmpTokenRegEx(1, unitWithoutPrefix);
            }

            public boolean isSIUnit() {
                char b = 92; // \ (backslash)
                char u = 94; // ^
                String exponent = "(" + b + u + "-?" + b + "d)";
                String unitKindGroup =
                    prefix + "?" + unitWithPrefix + exponent + "?(" + units + exponent + "?)*";
                String unitKindGroupWithoutPrefix =
                    unitWithoutPrefix + exponent + "?(" + units + exponent + "?)*";
                String regex = "(" + unitKindGroup + ")|(" + unitKindGroupWithoutPrefix + ")";
                return cmpTokenRegEx(1, regex);
            }
        }
    }

    /**
      * Every SIUnit is either a dimensionless unit 
      * such as 'deg' or a SIUnitExpression
      */
    SIUnit =
       SIUnitDimensionless | SIUnitCompound;

    /**
     * The SIUnitExpression describes an expression containing 
     * SIUnitBasics as primitives so that every combination 
     * of 'x*y', 'x/y', 'x^n' and '(x)' 
     * is possible
     */
    interface SIUnitCompound;

    SIUnitMult implements SIUnitCompound <10> =
        left:SIUnitCompound "*" right:SIUnitCompound;

    SIUnitOneDiv implements SIUnitCompound <20> =
        "1/" right:SIUnitCompound;

    SIUnitDiv implements SIUnitCompound <30> =
        left:SIUnitCompound "/" right:SIUnitCompound;

    SIUnitBracket implements SIUnitCompound <40> =
        "(" SIUnit ")";

    SIUnitExponent implements SIUnitCompound <50> =
        SIUnitCompound "^" exponent:SignedNatLiteral;

    /**
     * The SIUnitBasics are the primitives of the SIUnitExpressions 
     * 
     * SIUnitBasics contains the basic SI units without prefixes 
     * such as 'm', 's' or 'kg' 
     * as well as the basic SI units with prefixes 
     * such as 'km', 'mm' or 'ms'.
     *
     * Other derived or officialy accepted units are also contained 
     * ('h', 'day', 'Ohm', ...)
     */
    interface SIUnitBasic extends SIUnitCompound;

    /**
     * UnitBaseDimWithPrefix
     *
     * The regular expression is defined according to:
     * * https://en.wikipedia.org/wiki/Metric_prefix
     * * https://en.wikipedia.org/wiki/SI_base_unit
     * * https://en.wikipedia.org/wiki/SI_derived_unit
     * The regular expression is needed, because SI units shall not be
     * defined as keywords, because they would not be usable e.g. as
     * variable names in other places anymore.
     * See also functions available to handle the stored unit.
     */
    SIUnitWithPrefix implements SIUnitBasic <10> =
    { isSIUnit() }?
        (Name | NonNameUnit);

    token NonNameUnit =
         UnitKindGroup | UnitKindGroupWithoutPrefix;

    fragment token UnitKindGroup =
            UnitPrefix? UnitKindWithPrefix UnitExponent?
            ( UnitKind UnitExponent? )*;

    fragment token UnitKindGroupWithoutPrefix =
            UnitKindWithoutPrefix  UnitExponent?
            ( UnitKind UnitExponent? )*;

    fragment token UnitExponent = '^' '-'? ('1'..'9');

    fragment token UnitPrefix = 
         'Y'|'Z'|'E'|'P'|'T'|'G'|'M'|'k'|'h'|"da"|'d'|'c'|'m'|'u'
        |'µ'|'n'|'p'|'f'|'a'|'z'|'y';

    fragment token UnitKindWithPrefix =
         'm'|'g'|'s'|'A'|'K'|"mol"|"cd"|"Hz"|'N'|"Pa"|'J'|'W'|'C'
        |'V'|'F'|"Ohm"|'Ω'|'S'|"Wb"|'T'|'H'|"lm"|"lx"|"Bq"|"Gy"
        |"Sv"|"kat"|'l'|'L';
        
    fragment token UnitKindWithoutPrefix =
        "min"|'h'|'d'|"ha"|'t'|"au"|"Np"|"B"|"dB"|"eV"|"Da"|'u';

    fragment token UnitKind = UnitKindWithPrefix | UnitKindWithoutPrefix;

// TODO: to handle:
//Eine solche Definition hätte natürlich ein Risiko:
//    km/h könnte nun plötzlich an anderer Stelle fälschlicherweise nicht
//    mehr als Division zweier Variable verarbeitet werden (weshalb ich ja
//    Eine sehr fein begrenzte Definition des Tokens vorgenommen habe,
//    um das Problem zu begrenzen
//
//-------------
//Man könnte natürlich "VAh/km" immer noch als drei Token parsen,
//und da dann noSpace nutzen.
//
//    (( Anmerkung: ich war davon ausgegangen, dss "/" nur einmal auftritt. Das scheint nicht der Fall zu sein)
//        und die Klammern hatte ich auch ignoriert ,
//        gut dass es Erklärungen gibt: ```kg/m*s``` &rarr; ```((kg/m)*s)```))
//
//------------------
//Und übrigens:
// statt eine vorgegebene Funktion cmpTokenRegEx(1, .... mit
// länglichem mehrfach wiederholtem String
// könnte man auch eine eigendefinierte Funktion nutzen
// (und da dann solche langen Strings verbergen.
// -- sowas wie: {de.monticore.siunit.isSIUnit(foo())}?
//
// Und Marita sagt Ihnen, was da als foo() einzusetzen ist, um den
// String des nächsten Token zu bekommen.


    /**
     * OfficallyAcceptedUnit
     *
     * is realized like UnitBaseDimWithPrefix, using a regular matching 
     * expression according to:
     * https://en.wikipedia.org/wiki/Non-SI_units_mentioned_in_the_SI
     */
    OfficallyAcceptedUnit implements SIUnitBasic =
        { isUnitWithoutPrefix() }? unit:Name;

    /**
     * CelsiusFahrenheit matches "°C" and "°F"
     *
     * Lookahead needed at the beginning to distinguish with other alternatives
     */
    CelsiusFahrenheit implements SIUnitBasic =
        { cmpToken(2,"F","C") && noSpace(2) }? "°" (Name| NonNameUnit);


    /**
     * SIUnitDimensionless matches "°" and "deg|rad|sr"
     * according to see https://en.wikipedia.org/wiki/SI_derived_unit
     */
    SIUnitDimensionless implements SIUnitBasic =
        "°" |
        { next("deg","rad","sr") }? unit:Name;
        
}
